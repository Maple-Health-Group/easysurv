---
output: 
  github_document:
always_allow_html: yes
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include=FALSE}

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = '#>',
  fig.path = "man/figures/"
)

library(easysurv)
library(cli)

# The remaining code in this chunk is all to support cli output printing,
# and printing in a single code block. It preserves some of the colour lost by
# a github_document output.

options(crayon.enabled = TRUE)

ansi_aware_handler <- function(x, options) {
  paste0(
    "<pre class=\"r-output\"><code>",
    fansi::sgr_to_html(x = x, warn = FALSE, term.cap = "256"),
    "</code></pre>"
  )
}

# global store for output and messages
asconsole_output <- NULL

# override message hook
# if output option is 'asconsole', append message to global
# otherwise let knitr do its thing
knitr::knit_hooks$set(message = function(x, options) {
  if(!is.null(options$output)) {
    if(options$output == 'asconsole') {
      asconsole_output <<- c(asconsole_output, x)
      return(NULL)
    }
  }

  knitr::hooks_html()$message(x, options)
})

# override output hook
# if output option is 'asconsole', append output to global
# otherwise let knitr do its thing
knitr::knit_hooks$set(output = function(x, options) {
  if(!is.null(options$output)) {
    if(options$output == 'asconsole') {
      asconsole_output <<- c(asconsole_output, x)
      return(NULL)
    }
  }

  knitr::hooks_html()$output(x, options)
})

# override chunk hook
# if output option is 'asconsole', clear global and append formatted contents
# otherwise let knitr do its thing
knitr::knit_hooks$set(chunk = function(x, options) {
  if(!is.null(options$output)) {
    if(options$output == 'asconsole') {
      y <- paste(asconsole_output, collapse = "")
      y <- ansi_aware_handler(y, options) # new line
      #y <- knitr::hooks_html()$output(y, options)
      asconsole_output <<- NULL
      y <- paste(x, y, collapse = "")
      return(y)
    }
  }

  knitr::hooks_html()$chunk(x, options)
})

```

# easysurv <a href="https://maple-health-group.github.io/easysurv/"><img src="man/figures/logo.png" align="right" height="139" alt="easysurv website" /></a>

<!-- badges: start -->
[![R-CMD-check](https://github.com/Maple-Health-Group/easysurv/actions/workflows/check-standard.yaml/badge.svg)](https://github.com/Maple-Health-Group/easysurv/actions/workflows/check-standard.yaml)
[![test-coverage](https://github.com/Maple-Health-Group/easysurv/actions/workflows/test-coverage.yaml/badge.svg)](https://github.com/Maple-Health-Group/easysurv/actions/workflows/test-coverage.yaml)
<!-- badges: end -->

The *easysurv* R package provides tools to simplify survival data analysis and model fitting.

*easysurv* facilitates plotting Kaplan-Meier curves, assessing the proportional hazards assumption, estimating parametric survival models using engines such as `flexsurv`, `flexsurvspline`, `flexsurvcure` and `survival`, and exporting associated analyses to Excel.

By default, the package uses the `flexsurv` engine and provides a helpful starting point to explore survival extrapolations across frequently used distributions (such as exponential, generalized gamma, gamma, Gompertz, log-logistic, log-normal and Weibull).

## Installation

If you haven't already, install [R](https://www.r-project.org) and consider using [RStudio](https://posit.co/download/rstudio-desktop/) as your integrated development environment (IDE).


```{r install, eval = FALSE}
# You will need to have the pak package installed.
install.packages("pak")

# Then, install easysurv with the following line of code.
pak::pkg_install("Maple-Health-Group/easysurv")
```

## Getting started

```{r getting-started, eval = FALSE}
# Attach the easysurv library
library(easysurv)

# Open an example script
quick_start()
## Note: The default file name is "easysurv_start.R", but you can define your own, e.g.
## quick_start("my_file_name.R")

# Access help files
help(package = "easysurv")
```


## Examples
### Start by tidying your data...

```{r tidy-data, echo = TRUE}
# Load the easy_lung data from the easysurv package
# Recode the "status" variable to create an event indicator (0/1)
surv_data <- easy_lung |>
  dplyr::mutate(
    time = time,
    event = status - 1,
    group = sex
  )

# Make the group variable a factor and assign level labels.
surv_data <- surv_data |>
  dplyr::mutate_at("group", as.factor)
levels(surv_data$group) <- c("Male", "Female")
```

### ... then enjoy the easysurv functions! 

### `inspect_surv_data()`

```{r inspect, collapse = TRUE, output = "asconsole"}
inspect_surv_data(
  data = surv_data,
  time = "time",
  event = "event",
  group = "group"
)
```

### `get_km()`

Note that GitHub README files strip most of the colour and formatting from the console output. 

To see the fully formatted output of the following functions, run the code in your R console.

```{r get-KM, collapse = TRUE, output = "asconsole", fig.width=6, fig.height=5}
km_check <- get_km(
  data = surv_data,
  time = "time",
  event = "event",
  group = "group"
)

print(km_check)
```


### `test_ph()`


```{r test-PH, collapse = TRUE, output = "asconsole", fig.width=6, fig.height=5}
ph_check <- test_ph(
  data = surv_data,
  time = "time",
  event = "event",
  group = "group"
)

print(ph_check)
```


### `fit_models()`


```{r fit-models, collapse = TRUE, output = "asconsole", fig.width=6, fig.height=5}
separate_models <- fit_models(
  data = surv_data,
  time = "time",
  event = "event",
  predict_by = "group"
)

print(separate_models)
```

### `predict_and_plot()`


```{r plot-models, collapse = TRUE, output = "asconsole", fig.width=6, fig.height=5}
plots <- predict_and_plot(
  fit_models = separate_models,
  data = surv_data
)

print(plots)
```
