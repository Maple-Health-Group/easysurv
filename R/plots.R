#' Plot Survival Fits
#'
#' Plots the survival fits generated by the \code{fit_models} function.
#'
#' @param pred_data A data frame containing the survival predictions.
#' @param km_data A data frame containing the Kaplan-Meier survival data.
#' @param km_include Logical value indicating whether to include lines for
#'   Kaplan-Meier survival data. Default is \code{TRUE}.
#' @param legend_label Label for the legend. Default is "Model".
#' @param title Title of the plot. Default is \code{NULL}.
#' @param subtitle Subtitle of the plot. Default is \code{NULL}.
#'
#' @return A ggplot2 object.
#'
#' @export
#'
#' @import ggplot2
#' @importFrom tidyr pivot_longer
plot_surv <- function(pred_data, km_data, km_include = TRUE,
                      legend_label = "Model", title = NULL, subtitle = NULL) {
  # Create visible binding for R CMD check (pred_data)
  .eval_time <- survival <- model <- NULL

  # Create visible binding for R CMD check (km_data)
  time <- surv <- lower <- upper <- NULL

  # Pivot_longer so that ggplot2 is happy (requires data frame)
  long_data <- tidyr::pivot_longer(pred_data,
    cols = -".eval_time",
    names_to = "model",
    values_to = "survival"
  )

  # Initialise plot
  p <- ggplot2::ggplot()

  # KM as first layer
  if (km_include) {
    p <- p + ggplot2::geom_step(
      data = km_data,
      ggplot2::aes(
        x = time,
        y = surv
      ),
      color = "black"
    )
    p <- p + ggplot2::geom_ribbon(data = km_data, ggplot2::aes(
      x = time,
      ymin = lower,
      ymax = upper
    ), alpha = 0.2)
  }

  # Predictions as additional layer
  p <- p + ggplot2::geom_line(
    data = long_data,
    ggplot2::aes(
      x = .eval_time,
      y = survival,
      color = model,
      group = model
    )
  )


  # Add labels
  p <- p + ggplot2::labs(
    x = "Time",
    y = "Survival",
    color = ifelse(length(unique(long_data$model)) == 1,
      legend_label,
      paste0(legend_label, "s")
    )
  )

  if (!is.null(title)) {
    p <- p + ggplot2::ggtitle(title)
  }

  if (!is.null(subtitle)) {
    p <- p + ggplot2::labs(subtitle = subtitle)
  }

  # Add theme
  p <- p + ggplot2::theme_bw()

  p
}


#' Plot Smoothed Hazards
#'
#' Plots observed hazards and the hazards predicted by different models
#' generated by the \code{fit_models} function.
#'
#' @param pred_data A data frame containing the hazard predictions.
#' @param obs_data A data frame containing the observed hazards.
#' @param legend_label Label for the legend. Default is "Model".
#' @param title Title of the plot. Default is \code{NULL}.
#' @param subtitle Subtitle of the plot. Default is \code{NULL}.
#'
#' @return A ggplot2 object.
#'
#' @export
#'
#' @import ggplot2
#' @importFrom tidyr pivot_longer
plot_hazards <- function(pred_data, obs_data, legend_label = "Model",
                         title = NULL, subtitle = NULL) {
  # Create visible binding for R CMD check (pred_data)
  .eval_time <- hazards <- model <- NULL

  # Create visible binding for R CMD check (obs_data)
  time <- est <- lcl <- ucl <- NULL

  # Pivot_longer so that ggplot2 is happy (requires data frame)
  long_data <- tidyr::pivot_longer(pred_data,
    cols = -".eval_time",
    names_to = "model",
    values_to = "hazards"
  )

  # Initialise plot
  p <- ggplot2::ggplot()

  # Observed hazards as first layer
  p <- p + ggplot2::geom_line(
    data = obs_data,
    ggplot2::aes(x = time, y = est),
    color = "black"
  )
  p <- p + ggplot2::geom_ribbon(data = obs_data, ggplot2::aes(
    x = time,
    ymin = lcl,
    ymax = ucl
  ), alpha = 0.2)

  # Predictions as additional layer
  p <- p + ggplot2::geom_line(
    data = long_data,
    ggplot2::aes(
      x = .eval_time,
      y = hazards,
      color = model,
      group = model
    )
  )

  # Add labels
  p <- p + ggplot2::labs(
    x = "Time",
    y = "Hazards",
    color = ifelse(length(unique(long_data$model)) == 1,
      legend_label,
      paste0(legend_label, "s")
    )
  )

  if (!is.null(title)) {
    p <- p + ggplot2::ggtitle(title)
  }

  if (!is.null(subtitle)) {
    p <- p + ggplot2::labs(subtitle = subtitle)
  }

  upper_y <- ggplot2::layer_scales(p)$y$range$range[2]

  if (upper_y > 1) {
    p <- p + ggplot2::ylim(NA, 1)
  }

  # Add theme
  p <- p + ggplot2::theme_bw()

  p
}

#' Plot Kaplan-Meier Data
#'
#' Generates a Kaplan-Meier survival curve plot using
#' \code{\link[ggsurvfit]{ggsurvfit}} with customisable options.
#' This function provides sensible defaults while allowing for customisation.
#'
#' @param fit A \code{\link[survival]{survfit}} object representing the
#'   survival data.
#' @param risk_table Logical value indicating whether to include a risk table
#'   below the plot. Default is \code{TRUE}.
#' @param median_line Logical value indicating whether to include a line
#'   representing the median survival time. Default is \code{TRUE}.
#' @param legend_position Position of the legend in the plot. Default is
#'   "bottom".
#' @param plot_theme ggplot2 theme for the plot. Default is
#'   \code{ggplot2::theme_bw()}.
#' @param xlab Label for the x-axis. Default is "Time".
#' @param ylab Label for the y-axis. Default is "Survival Probability (%)".
#' @return A ggplot object representing the Kaplan-Meier survival curve plot.
#'
#' @export
#'
#' @importFrom ggplot2 xlab ylab theme
#' @importFrom ggsurvfit add_censor_mark add_risktable add_quantile
#' @importFrom ggsurvfit ggsurvfit scale_ggsurvfit
#' @importFrom ggsurvfit theme_ggsurvfit_default theme_risktable_boxed
plot_km <- function(fit,
                    risk_table = TRUE,
                    median_line = TRUE,
                    legend_position = "bottom",
                    plot_theme = ggplot2::theme_bw(),
                    xlab = "Time",
                    ylab = "Survival Probability (%)") {
  out <- ggsurvfit::ggsurvfit(fit,
    type = "survival",
    theme = plot_theme
  ) +
    ggsurvfit::add_censor_mark() +
    ggplot2::xlab(xlab) +
    ggplot2::ylab(ylab) +
    ggplot2::theme(legend.position = legend_position)

  if (risk_table) {
    out <- out + ggsurvfit::add_risktable(
      risktable_stats = "n.risk",
      stats_label = list(n.risk = "Number at risk"),
      theme = ggsurvfit::theme_risktable_boxed()
    )
  }

  out <- out + ggsurvfit::scale_ggsurvfit()

  if (median_line) {
    out <- out + ggsurvfit::add_quantile(linetype = 2)
  }

  out
}

#' Cumulative Log Log Plot
#'
#' Generates a Cumulative Log Log survival curve plot using
#' \code{\link[ggsurvfit]{ggsurvfit}} with customisable options.
#' This function provides sensible defaults while allowing for customisation.
#'
#' @param fit A \code{\link[survival]{survfit}} object representing the
#'   survival data.
#' @param risk_table Logical value indicating whether to include a risk table
#'   below the plot. Default is \code{TRUE}.
#' @param median_line Logical value indicating whether to include a line
#'   representing the median survival time. Default is \code{TRUE}.
#' @param legend_position Position of the legend in the plot. Default is
#'   "bottom".
#' @param plot_theme ggplot2 theme for the plot. Default is
#'   \code{ggplot2::theme_bw()}.
#' @param xlab Label for the x-axis. Default is "Time (log-scaled)".
#' @param ylab Label for the y-axis. Default is "log(-log(S(t)))".
#' @return A ggplot object representing the Kaplan-Meier survival curve plot.
#'
#' @export
#'
#' @importFrom ggsurvfit add_censor_mark add_risktable add_quantile
#' @importFrom ggsurvfit theme_ggsurvfit_default theme_risktable_boxed
#' @importFrom scales pseudo_log_trans
plot_cloglog <- function(fit,
                         risk_table = FALSE,
                         median_line = FALSE,
                         legend_position = "bottom",
                         plot_theme = ggplot2::theme_bw(),
                         xlab = "Time (log-scaled)",
                         ylab = "log(-log(S(t)))") {
  out <- ggsurvfit::ggsurvfit(fit,
    type = "cloglog",
    theme = plot_theme
  ) +
    ggsurvfit::add_censor_mark() +
    ggplot2::xlab(xlab) +
    ggplot2::ylab(ylab) +
    ggplot2::theme(legend.position = legend_position) +
    ggplot2::scale_x_continuous(
      transform = scales::pseudo_log_trans(sigma = 0.01),
      labels = function(x) round(as.numeric(x), digits = 2)
    )

  # Used scales::pseudo_log_trans(sigma = 0.01) to avoid "log" and the
  # infinite values in log-transformed axis.

  if (risk_table) {
    out <- out + ggsurvfit::add_risktable(
      risktable_stats = "n.risk",
      stats_label = list(n.risk = "Number at risk"),
      theme = ggsurvfit::theme_risktable_boxed()
    )
  }

  if (median_line) {
    out <- out + ggsurvfit::add_quantile(linetype = 2)
  }

  out
}


#' Plot Schoenfeld Residuals
#'
#' This function creates a visual representation of Schoenfeld residuals from a
#' Cox proportional hazards model.
#' It allows for customization of the plot, including the addition of horizontal
#' and smoothed lines, and styling of points and plot elements.
#'
#' @param residuals A data frame containing the Schoenfeld residuals, typically
#'   with columns `time`, `residual`, `transform`, and `variable`.
#' @param hline Logical. If `TRUE`, a horizontal line is added to the plot.
#'   Default is `TRUE`.
#' @param sline Logical. If `TRUE`, a smooth line is added to the plot.
#'   Default is `TRUE`.
#' @param sline_se Logical. If `TRUE`, confidence intervals are displayed around
#'   the smooth line. Default is `TRUE`.
#' @param hline_col Color of the horizontal line. Default is `"red"`.
#' @param hline_size Line width of the horizontal line. Default is `1`.
#' @param hline_alpha Transparency of the horizontal line. Default is `1`.
#' @param hline_yintercept Y-intercept for the horizontal line. Default is `0`.
#' @param hline_lty Line type for the horizontal line. Default is `"dashed"`.
#' @param sline_col Color of the smooth line. Default is `"blue"`.
#' @param sline_size Line width of the smooth line. Default is `1`.
#' @param sline_alpha Transparency of the smooth line. Default is `0.3`.
#' @param sline_lty Line type for the smooth line. Default is `"dashed"`.
#' @param point_col Color of the points representing residuals. Default is
#'   `"black"`.
#' @param point_size Size of the points representing residuals. Default is `1`.
#' @param point_shape Shape of the points representing residuals. Default is
#'   `19`.
#' @param point_alpha Transparency of the points representing residuals. Default
#'   is `1`.
#' @param plot_theme A ggplot2 theme for the plot. Default is
#' `ggplot2::theme_bw()`.
#'
#' @return A ggplot object representing the plot of Schoenfeld residuals.
#'
#' @export
#'
#' @importFrom ggplot2 geom_point geom_hline geom_smooth
#' @importFrom ggplot2 facet_wrap xlab ylab theme_bw
#'
#'
plot_schoenfeld <- function(residuals,
                            hline = TRUE,
                            sline = TRUE,
                            sline_se = TRUE,
                            hline_col = "red",
                            hline_size = 1,
                            hline_alpha = 1,
                            hline_yintercept = 0,
                            hline_lty = "dashed",
                            sline_col = "blue",
                            sline_size = 1,
                            sline_alpha = 0.3,
                            sline_lty = "dashed",
                            point_col = "black",
                            point_size = 1,
                            point_shape = 19,
                            point_alpha = 1,
                            plot_theme = ggplot2::theme_bw()) {
  # Create visible binding for R CMD check.
  time <- residual <- NULL

  trans_string <- ifelse(unique(residuals$transform) == "identity", "t",
    paste0(unique(residuals$transform), "(t)")
  )

  gg_zph <- ggplot2::ggplot(residuals, ggplot2::aes(x = time, y = residual)) +
    ggplot2::geom_point() +
    ggplot2::facet_wrap(~variable, nrow = 2, scales = "free_y") +
    ggplot2::xlab(trans_string) +
    ggplot2::ylab(expression(beta(t)))

  if (hline) {
    gg_zph <- gg_zph + ggplot2::geom_hline(
      yintercept = hline_yintercept, col = hline_col,
      linewidth = hline_size, lty = hline_lty, alpha = hline_alpha
    )
  }

  if (sline) {
    gg_zph <- gg_zph + ggplot2::geom_smooth(
      col = sline_col, se = sline_se, method = "loess",
      linewidth = sline_size, lty = sline_lty, alpha = sline_alpha,
      formula = y ~ x
    )
  }

  gg_zph <- gg_zph + plot_theme

  gg_zph
}
