#' Plot Survival Fits
#'
#' Plots the survival fits generated by the \code{fit_models} function.
#'
#' @param data A data frame containing the survival predictions.
#'
#' @return A ggplot2 object.
#'
#' @export
#'
#' @import ggplot2
#' @importFrom tidyr pivot_longer
plot_fits <- function(data) {

  # Create visible binding for R CMD check.
  .eval_time <- Survival <- Model <- NULL

  # Pivot_longer so that ggplot2 is happy (requires data frame)
  long_data <- tidyr::pivot_longer(data,
                                   cols = -".eval_time",
                                   names_to = "Model",
                                   values_to = "Survival"
  )

  p <- ggplot(data = long_data, aes(x = .eval_time, y = Survival))
  p <- p + geom_line(aes(color = Model, group = Model))
  p <- p + labs(
    x = "Time",
    y = "Survival",
    color = ifelse(length(unique(long_data$Model)) == 1, "Model", "Models")
  )
  p <- p + theme_bw()

  # more can be done here to improve this.

  # may want an optional KM argument.

  return(p)
}

#' Plot Kaplan-Meier Data
#'
#' Generates a Kaplan-Meier survival curve plot using
#' \code{\link[ggsurvfit]{ggsurvfit}} with customisable options.
#' This function provides sensible defaults while allowing for customisation.
#'
#' @param fit A \code{\link[survival]{survfit}} object representing the
#' survival data.
#' @param risk_table Logical value indicating whether to include a risk table
#' below the plot. Default is \code{TRUE}.
#' @param median_line Logical value indicating whether to include a line
#' representing the median survival time. Default is \code{TRUE}.
#' @param legend_position Position of the legend in the plot. Default is
#' "bottom".
#' @param plot_theme ggplot2 theme for the plot. Default is
#' \code{ggplot2::theme_bw()}.
#' @param xlab Label for the x-axis. Default is "Time".
#' @param ylab Label for the y-axis. Default is "Survival Probability (%)".
#' @return A ggplot object representing the Kaplan-Meier survival curve plot.
#'
#' @export
#'
#' @importFrom ggsurvfit add_censor_mark add_risktable add_quantile
#' @importFrom ggsurvfit ggsurvfit scale_ggsurvfit
#' @importFrom ggsurvfit theme_ggsurvfit_default theme_risktable_boxed
plot_KM <- function(fit,
                     risk_table = TRUE,
                     median_line = TRUE,
                    legend_position = "bottom",
                    plot_theme = ggplot2::theme_bw(),
                     xlab = "Time",
                     ylab = "Survival Probability (%)") {

  out <- ggsurvfit::ggsurvfit(fit,
                              type = "survival",
                              theme = plot_theme) +
    ggsurvfit::add_censor_mark() +
    xlab(xlab) +
    ylab(ylab) +
    theme(legend.position = legend_position)

  if (risk_table) {
    out <- out + ggsurvfit::add_risktable(
    risktable_stats = "n.risk",
    stats_label = list(n.risk = "Number at risk"),
    theme = ggsurvfit::theme_risktable_boxed()
    )
  }

  out <- out + scale_ggsurvfit()

  if (median_line) {
    out <- out + ggsurvfit::add_quantile(linetype = 2)
  }

  return(out)
}

#' Cumulative Log Log Plot
#'
#' Generates a Cumulative Log Log survival curve plot using
#' \code{\link[ggsurvfit]{ggsurvfit}} with customisable options.
#' This function provides sensible defaults while allowing for customisation.
#'
#' @param fit A \code{\link[survival]{survfit}} object representing the
#' survival data.
#' @param risk_table Logical value indicating whether to include a risk table
#' below the plot. Default is \code{TRUE}.
#' @param median_line Logical value indicating whether to include a line
#' representing the median survival time. Default is \code{TRUE}.
#' @param legend_position Position of the legend in the plot. Default is
#' "bottom".
#' @param plot_theme ggplot2 theme for the plot. Default is
#' \code{ggplot2::theme_bw()}.
#' @param xlab Label for the x-axis. Default is "Time".
#' @param ylab Label for the y-axis. Default is "Log Minus Log Survival".
#' @return A ggplot object representing the Kaplan-Meier survival curve plot.
#'
#' @export
#'
#' @importFrom ggsurvfit add_censor_mark add_risktable add_quantile
#' @importFrom ggsurvfit ggsurvfit scale_ggsurvfit
#' @importFrom ggsurvfit theme_ggsurvfit_default theme_risktable_boxed
plot_cloglog <- function(fit,
                    risk_table = FALSE,
                    median_line = FALSE,
                    legend_position = "bottom",
                    plot_theme = ggplot2::theme_bw(),
                    xlab = "Time",
                    ylab = "Log Minus Log Survival") {

  out <- ggsurvfit::ggsurvfit(fit,
                              type = "cloglog",
                              theme = plot_theme) +
    ggsurvfit::add_censor_mark() +
    xlab(xlab) +
    ylab(ylab) +
    theme(legend.position = legend_position) +
    scale_x_continuous(transform = "log",
                       labels = function(x) round(as.numeric(x), digits=2))

  if (risk_table) {
    out <- out + ggsurvfit::add_risktable(
      risktable_stats = "n.risk",
      stats_label = list(n.risk = "Number at risk"),
      theme = ggsurvfit::theme_risktable_boxed()
    )
  }

  if (median_line) {
    out <- out + ggsurvfit::add_quantile(linetype = 2)
  }

  return(out)
}

#' Modified version of \code{\link[survminer]{ggcoxdiagnostics}} to replace
#' \code{gather_} and set \code{geom_smooth} formulae
#'
#' @description Displays diagnostics graphs presenting goodness of Cox
#' Proportional Hazards Model fit, that
#' can be calculated with \code{\link[survival]{coxph}} function.
#' This function is largely identical to \code{ggcoxdiagnostics}
#' from the \code{survminer} package with some minor alterations in order to
#' accommodate \code{easysurv} functionality.
#'
#' @param fit_coxph An object of class \code{\link[survival]{coxph.object}} -
#' created with \code{\link[survival]{coxph}} function.
#' @param data Data for fit_coxph
#' @param formula Formula for fit_coxph
#' @param point.col,point.size,point.shape,point.alpha color, size, shape and
#' visibility to be used for points.
#' @param hline.col,hline.size,hline.lty,hline.alpha,hline.yintercept color,
#' size, linetype, visibility and Y-axis coordinate to be used for
#' \code{\link[ggplot2]{geom_hline}}.
#'        Used only when \code{hline = TRUE}.
#' @param sline.col,sline.size,sline.lty,sline.alpha color, size,
#' linetype and visibility to be used for \code{\link[ggplot2]{geom_smooth}}.
#'        Used only when \code{sline = TRUE}.
#' @param hline a logical - should the horizontal line be added to highlight
#' the \code{Y=0} level.
#' @param sline,sline.se a logical - should the smooth line be added to
#' highlight the local average for residuals.
#'
#' @param plot.theme ggplot2 theme for the plot. Default is theme_bw()
#' @param title,subtitle,caption main title, subtitle and caption.
#'
#' @return Returns an object of class \code{ggplot}.
#'
#' @importFrom ggplot2 aes
#' @importFrom ggplot2 facet_wrap
#' @importFrom ggplot2 ggplot
#' @importFrom ggplot2 geom_smooth
#' @importFrom ggplot2 geom_point
#' @importFrom rlang f_rhs
#' @importFrom stats predict
#' @importFrom stats residuals
#' @importFrom stringr fixed
#' @importFrom stringr str_replace_all
#' @importFrom survival coxph
#'
#' @examples
#' \dontrun{
#' #to add
#' }
#'
#' @export
plot_schoenfeld <- function(
    fit_coxph,
    data,
    formula,
    hline = TRUE,
    sline = TRUE, sline.se = TRUE,
    hline.col = "red", hline.size = 1, hline.alpha = 1, hline.yintercept = 0,
    hline.lty = "dashed",
    sline.col = "blue", sline.size = 1, sline.alpha = 0.3, sline.lty = "dashed",
    point.col = "black", point.size = 1, point.shape = 19, point.alpha = 1,
    title = NULL, subtitle = NULL, caption = NULL,
    plot.theme = theme_bw()) {

  formula_rhs <- deparse(rlang::f_rhs(formula))

  res <- as.data.frame(stats::resid(fit_coxph, type = "schoenfeld"))

  # The reason both fit_coxph & [data + formula] are requested is that
  # we wanted to assign nicer labels to the facets. But the function was
  # struggling to evaluate residuals unless called in same context.

  .facet <- FALSE

  xlabel <- "The index number of observations"
  ylabel <- "Residuals (type = schoenfeld)"

  xval <- seq_len(nrow(res))
  xlabel <- "Observation Id"

  col_names <- names(stats::coef(fit_coxph))
  colnames(res) <- col_names
  res$xval <- xval

  # # Original based on gather.
  # data2plot <- tidyr::gather(res,
  #                            key = "covariate", value = "res",
  #                            col_names
  # )
  #
  # # Newer based on pivot_longer (since gather was deprecated)
  # data2plot <- tidyr::pivot_longer(res,
  #                            names_to = "covariate", values_to = "res",
  #                            col_names
  # )

  # Newest to remove dependency on tidyr.
  data2plot <- data.frame(
    covariate = rep(col_names, each = nrow(res)),
    res = unname(res[1]),
    xval = res$xval,
    row.names = NULL
  )

  data2plot$covariate <-
    stringr::str_replace_all(data2plot$covariate,
                             stringr::fixed(formula_rhs),
                             "")

  gplot <- ggplot2::ggplot(ggplot2::aes(xval, res), data = data2plot) +
    ggplot2::geom_point(
      col = point.col, shape = point.shape,
      size = point.size, alpha = point.alpha
    )

  if (hline) {
    gplot <- gplot + ggplot2::geom_hline(
      yintercept = hline.yintercept, col = hline.col,
      size = hline.size, lty = hline.lty, alpha = hline.alpha
    )
  }

  if (sline) {
    gplot <- gplot + ggplot2::geom_smooth(
      col = sline.col, se = sline.se, method = "loess",
      size = sline.size, lty = sline.lty, alpha = sline.alpha,
      formula = y ~ x
    )
  }

  gplot <- gplot + ggplot2::labs(
    x = xlabel, y = ylabel, title = title,
    subtitle = subtitle, caption = caption
  )

  gplot <- gplot + plot.theme

  gplot <- gplot + ggplot2::facet_wrap(~covariate, scales = "free")
  gplot
}


#' Plot smoothed hazards of survival data
#'
#' This function generates a plot showing the hazards of the underlying
#' survival data, along with the hazards
#' predicted by different models from a \code{\link[survHE]{fit.models}} object.
#' It provides a visual comparison between observed hazards
#' and the hazards predicted by different models.
#'
#' @param data The survival data as a data frame with columns
#' \code{time} and \code{event}.
#' @param time The name of the time variable in data.
#' @param event The name of the event variable in data.
#' @param fits The \code{\link[survHE]{fit.models}} object containing
#' survival models
#' @param t A vector of time points at which to calculate the hazards.
#' @param group The group number of the strata
#' @param title The title of the plot.
#' @param subtitle The subtitle of the plot.
#' @param ylab The label for the y-axis.
#' @param xlab The label for the x-axis.
#' @param ylimit The upper limit of the y-axis to adjust the scale of the plot.
#'
#' @param font.family The name of the font for the plot. Default is
#' "Roboto Condensed".
#' @param plot.theme ggplot2 theme for the plot. Default is
#' \code{\link{theme_bw}()}.
#' @param use_plotly Optional. Whether to return a `plotly` output
#' for the plots. Default is FALSE.
#'
#' @importFrom rlang .data
#' @importFrom bshazard bshazard
#' @importFrom dplyr bind_rows
#' @importFrom ggplot2 ggplot
#' @importFrom ggplot2 geom_line
#' @importFrom ggplot2 geom_ribbon
#' @importFrom ggplot2 guides
#' @importFrom ggplot2 guide_legend
#' @importFrom ggplot2 ylim
#' @importFrom plotly ggplotly
#' @importFrom plotly config
#' @importFrom plotly layout
#' @importFrom survival Surv
#' @importFrom stats as.formula
#'
#' @export
#'
#' @return A ggplot object representing the plot of hazards.
#'
#' @examples
#' \dontrun{
#' library(survival)
#'
#' example <- lung |>
#'   mutate(event = status) |>
#'   select(time, event, sex)
#'
#' models <- survHE::fit.models(
#'   formula = Surv(time, event) ~ as.factor(sex),
#'   data = example,
#'   distr = c("exp", "weibull"),
#'   method = "mle"
#' )
#'
#' plot_smoothed_hazards(
#'   data = example,
#'   time = "time",
#'   event = "event",
#'   fits = models,
#'   t = 0:2000,
#'   title = "Smoothed hazards"
#' )
#' }
#'
plot_smoothed_hazards <- function(data,
                                  time,
                                  event,
                                  fits,
                                  t,
                                  # Optional arguments below
                                  group = 1,
                                  title = "",
                                  subtitle = "",
                                  ylab = "Hazard",
                                  xlab = "Time",
                                  ylimit = NULL,
                                  font.family = "Roboto Condensed",
                                  plot.theme = theme_bw(),
                                  use_plotly = FALSE) {

  # Appeasing R CMD check
  dist <- est <- lcl <- ucl <- NULL

  # Define the survival formula for bshazard
  my_formula <- stats::as.formula(
    paste0("survival::Surv(time = ", time, ", event = ", event, ") ~ 1"))

  # Calculate smoothed estimate of hazards based on B-splines (bshazard)
  observed_hazards <- with(bshazard::bshazard(my_formula,
                                              data = data,
                                              verbose = FALSE),
                           data.frame(time, hazard, lower.ci, upper.ci)) |>
    dplyr::rename(est = .data$hazard,
                  lcl = .data$lower.ci,
                  ucl = .data$upper.ci)

  # Label the observed hazards and assign a thicker line width for the plot
  observed_hazards$dist <- "Observed"
  observed_hazards$linewidth <- 2.5

  # Obtain the predicted hazards from the fits
  predicted_hazards <- lapply(fits$models, function(dist) {
    summary_hazards <- as.data.frame(
      summary(dist, type = "hazard", t = t, ci = FALSE)[[group]])

    # Thinner linewidth for non-observed hazards
    summary_hazards$linewidth <- 1

    return(summary_hazards)
  })

  # Combine predicted hazards into manageable object
  predicted_hazards <- Map(cbind,
                           predicted_hazards,
                           dist = names(predicted_hazards))

  # Combine observed and predicted hazards into one object
  all_hazards <- do.call(dplyr::bind_rows,
                         c(list(observed_hazards), predicted_hazards))

  # Put the "Observed" line at the top of the plot legend.
  all_hazards$dist <- factor(all_hazards$dist,
                             levels = unique(all_hazards$dist))

  # Sometimes the estimated hazard is relatively much larger for a distribution
  # that it extends the y-axis significantly and makes it difficult to interpret
  # the plot.
  # The below logic attempts to define a reasonable upper limit for the y-axis.
  if (is.null(ylimit)) {

    # Obtain maximum estimated hazard
    max_est_hazard <- max(all_hazards$est, na.rm = TRUE)

    # Obtain upper confidence interval of observed hazard
    max_observed_u <- max(observed_hazards$ucl, na.rm = TRUE)

    # If estimated hazards don't go beyond the upper confidence limit of the
    # observed hazards, that's fine. Otherwise, extend the plot arbitrarily.
    if (max_observed_u > max_est_hazard) {
      max_hazard <- max_observed_u
    } else {
      max_hazard <- max_observed_u * 4
    }

    # Don't need to show hazards that would go beyond 1.
    ylimit <- min(1, max_hazard)
  }

  # Create the plot window
  out <- ggplot2::ggplot(all_hazards, aes(
    x = .data$time,
    y = .data$est,
    group = .data$dist
  )) +
    # Add the lines
    ggplot2::geom_line(aes(col = .data$dist, linewidth = I(.data$linewidth)),
                       na.rm = TRUE) +
    # Add labels
    labs(
      col = "Models",
      y = ylab,
      x = xlab,
      title = title,
      subtitle = subtitle
    ) +
    # Legend line width matching that in plot
    ggplot2::guides(
      colour = ggplot2::guide_legend(override.aes = list(linewidth = 1))) +
    # Assign y limit.
    ggplot2::ylim(NA, ylimit)

  if (!use_plotly) {
    # Add the ribbon for the confidence interval
    out <- out +
      ggplot2::geom_ribbon(
        data = observed_hazards,
        aes(
          ymin = .data$lcl,
          ymax = .data$ucl,
          fill = .data$dist
        ),
        alpha = 0.3, # transparency
        show.legend = FALSE
      )
  }

  out <- out + plot.theme +
    theme(text          = element_text(family = font.family),
          plot.title    = element_text(family = font.family),
          plot.subtitle = element_text(family = font.family),
          axis.title.x  = element_text(family = font.family),
          axis.title.y  = element_text(family = font.family),
          axis.text.x   = element_text(family = font.family),
          axis.text.y   = element_text(family = font.family))

  # Conditionally convert to a plotly object
  if (use_plotly) {
    # Define the 'text' aesthetic used for hover tooltips
    out_plotly <- out + aes(text = paste0(
      "<b>",
      dist,
      "</b>",
      " Time: ",
      format(time, big.mark = ",", digits = 2, nsmall = 2, trim = TRUE),
      ", Hazard: ",
      sprintf(est, fmt = '%.3f'),
      ifelse(dist == "Observed",
             paste0(" (",
                    sprintf(lcl, fmt = '%.3f'),
                    ", ",
                    sprintf(ucl, fmt = '%.3f'),
                    ")" ),
             ""))
    )

    # Convert ggplot to plotly via ggplotly
    # Disable some options, otherwise overwhelming.
    out_plotly <- plotly::ggplotly(out_plotly, tooltip = "text") |>
      plotly::config(modeBarButtonsToRemove = c('zoom',
                                                'pan2d',
                                                'zoomIn',
                                                'zoomOut',
                                                'autoScale',
                                                'select2d',
                                                'lasso2d'),
                     displaylogo = FALSE) |>
      plotly::layout(hovermode = "x unified")

    # ggplotly seems to convert the distributions in the legend to:
    # "(Exponential,1)"
    # so here the code removes the "(,1)" wrapping.
    for (i in seq_along(out_plotly[["x"]][["data"]])) {
      temp_name <- out_plotly[["x"]][["data"]][[i]][["name"]]
      if (startsWith(temp_name,"(") & endsWith(temp_name,",1)")) {
        out_plotly[["x"]][["data"]][[i]][["name"]] <-
          substring(temp_name,
                    2,
                    nchar(temp_name)-3)
      }
    }

    return(out_plotly)
  }

  return(out)
}
