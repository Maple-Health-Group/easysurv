#' Plot Survival Fits
#'
#' Plots the survival fits generated by the \code{fit_models} function.
#'
#' @param data A data frame containing the survival predictions.
#'
#' @return A ggplot2 object.
#'
#' @export
#'
#' @import ggplot2
#' @importFrom tidyr pivot_longer
#' @importFrom scales pseudo_log_trans
plot_fits <- function(data) {
  # Create visible binding for R CMD check.
  .eval_time <- survival <- model <- NULL

  # Pivot_longer so that ggplot2 is happy (requires data frame)
  long_data <- tidyr::pivot_longer(data,
    cols = -".eval_time",
    names_to = "model",
    values_to = "survival"
  )

  p <- ggplot(data = long_data, aes(x = .eval_time, y = survival))
  p <- p + geom_line(aes(color = model, group = model))
  p <- p + labs(
    x = "Time",
    y = "Survival",
    color = ifelse(length(unique(long_data$model)) == 1, "Model", "Models")
  )
  p <- p + theme_bw()

  # more can be done here to improve this.

  # may want an optional km argument.

  p
}

#' Plot Kaplan-Meier Data
#'
#' Generates a Kaplan-Meier survival curve plot using
#' \code{\link[ggsurvfit]{ggsurvfit}} with customisable options.
#' This function provides sensible defaults while allowing for customisation.
#'
#' @param fit A \code{\link[survival]{survfit}} object representing the
#'   survival data.
#' @param risk_table Logical value indicating whether to include a risk table
#'   below the plot. Default is \code{TRUE}.
#' @param median_line Logical value indicating whether to include a line
#'   representing the median survival time. Default is \code{TRUE}.
#' @param legend_position Position of the legend in the plot. Default is
#'   "bottom".
#' @param plot_theme ggplot2 theme for the plot. Default is
#'   \code{ggplot2::theme_bw()}.
#' @param xlab Label for the x-axis. Default is "Time".
#' @param ylab Label for the y-axis. Default is "Survival Probability (%)".
#' @return A ggplot object representing the Kaplan-Meier survival curve plot.
#'
#' @export
#'
#' @importFrom ggsurvfit add_censor_mark add_risktable add_quantile
#' @importFrom ggsurvfit ggsurvfit scale_ggsurvfit
#' @importFrom ggsurvfit theme_ggsurvfit_default theme_risktable_boxed
plot_km <- function(fit,
                    risk_table = TRUE,
                    median_line = TRUE,
                    legend_position = "bottom",
                    plot_theme = ggplot2::theme_bw(),
                    xlab = "Time",
                    ylab = "Survival Probability (%)") {
  out <- ggsurvfit::ggsurvfit(fit,
    type = "survival",
    theme = plot_theme
  ) +
    ggsurvfit::add_censor_mark() +
    xlab(xlab) +
    ylab(ylab) +
    theme(legend.position = legend_position)

  if (risk_table) {
    out <- out + ggsurvfit::add_risktable(
      risktable_stats = "n.risk",
      stats_label = list(n.risk = "Number at risk"),
      theme = ggsurvfit::theme_risktable_boxed()
    )
  }

  out <- out + scale_ggsurvfit()

  if (median_line) {
    out <- out + ggsurvfit::add_quantile(linetype = 2)
  }

  out
}

#' Cumulative Log Log Plot
#'
#' Generates a Cumulative Log Log survival curve plot using
#' \code{\link[ggsurvfit]{ggsurvfit}} with customisable options.
#' This function provides sensible defaults while allowing for customisation.
#'
#' @param fit A \code{\link[survival]{survfit}} object representing the
#'   survival data.
#' @param risk_table Logical value indicating whether to include a risk table
#'   below the plot. Default is \code{TRUE}.
#' @param median_line Logical value indicating whether to include a line
#'   representing the median survival time. Default is \code{TRUE}.
#' @param legend_position Position of the legend in the plot. Default is
#'   "bottom".
#' @param plot_theme ggplot2 theme for the plot. Default is
#'   \code{ggplot2::theme_bw()}.
#' @param xlab Label for the x-axis. Default is "Time (log-scaled)".
#' @param ylab Label for the y-axis. Default is "log(-log(S(t)))".
#' @return A ggplot object representing the Kaplan-Meier survival curve plot.
#'
#' @export
#'
#' @importFrom ggsurvfit add_censor_mark add_risktable add_quantile
#' @importFrom ggsurvfit ggsurvfit scale_ggsurvfit
#' @importFrom ggsurvfit theme_ggsurvfit_default theme_risktable_boxed
plot_cloglog <- function(fit,
                         risk_table = FALSE,
                         median_line = FALSE,
                         legend_position = "bottom",
                         plot_theme = ggplot2::theme_bw(),
                         xlab = "Time (log-scaled)",
                         ylab = "log(-log(S(t)))") {
  out <- ggsurvfit::ggsurvfit(fit,
    type = "cloglog",
    theme = plot_theme
  ) +
    ggsurvfit::add_censor_mark() +
    xlab(xlab) +
    ylab(ylab) +
    theme(legend.position = legend_position) +
    scale_x_continuous(
      transform = scales::pseudo_log_trans(sigma = 0.01),
      labels = function(x) round(as.numeric(x), digits = 2)
    )

  # Used scales::pseudo_log_trans(sigma = 0.01) to avoid "log" and the
  # infinite values in log-transformed axis.

  if (risk_table) {
    out <- out + ggsurvfit::add_risktable(
      risktable_stats = "n.risk",
      stats_label = list(n.risk = "Number at risk"),
      theme = ggsurvfit::theme_risktable_boxed()
    )
  }

  if (median_line) {
    out <- out + ggsurvfit::add_quantile(linetype = 2)
  }

  out
}


#' Plot Schoenfeld Residuals
#'
#' This function creates a visual representation of Schoenfeld residuals from a
#' Cox proportional hazards model.
#' It allows for customization of the plot, including the addition of horizontal
#' and smoothed lines, and styling of points and plot elements.
#'
#' @param residuals A data frame containing the Schoenfeld residuals, typically
#'   with columns `time`, `residual`, `transform`, and `variable`.
#' @param hline Logical. If `TRUE`, a horizontal line is added to the plot.
#'   Default is `TRUE`.
#' @param sline Logical. If `TRUE`, a smooth line is added to the plot.
#'   Default is `TRUE`.
#' @param sline_se Logical. If `TRUE`, confidence intervals are displayed around
#'   the smooth line. Default is `TRUE`.
#' @param hline_col Color of the horizontal line. Default is `"red"`.
#' @param hline_size Line width of the horizontal line. Default is `1`.
#' @param hline_alpha Transparency of the horizontal line. Default is `1`.
#' @param hline_yintercept Y-intercept for the horizontal line. Default is `0`.
#' @param hline_lty Line type for the horizontal line. Default is `"dashed"`.
#' @param sline_col Color of the smooth line. Default is `"blue"`.
#' @param sline_size Line width of the smooth line. Default is `1`.
#' @param sline_alpha Transparency of the smooth line. Default is `0.3`.
#' @param sline_lty Line type for the smooth line. Default is `"dashed"`.
#' @param point_col Color of the points representing residuals. Default is
#'   `"black"`.
#' @param point_size Size of the points representing residuals. Default is `1`.
#' @param point_shape Shape of the points representing residuals. Default is
#'   `19`.
#' @param point_alpha Transparency of the points representing residuals. Default
#'   is `1`.
#' @param plot_theme A ggplot2 theme for the plot. Default is
#' `ggplot2::theme_bw()`.
#'
#' @return A ggplot object representing the plot of Schoenfeld residuals.
#'
#' @export
#'
#' @importFrom ggplot2 geom_point geom_hline geom_smooth
#' @importFrom ggplot2 facet_wrap xlab ylab theme_bw
#'
#'
plot_schoenfeld <- function(residuals,
                            hline = TRUE,
                            sline = TRUE,
                            sline_se = TRUE,
                            hline_col = "red",
                            hline_size = 1,
                            hline_alpha = 1,
                            hline_yintercept = 0,
                            hline_lty = "dashed",
                            sline_col = "blue",
                            sline_size = 1,
                            sline_alpha = 0.3,
                            sline_lty = "dashed",
                            point_col = "black",
                            point_size = 1,
                            point_shape = 19,
                            point_alpha = 1,
                            plot_theme = ggplot2::theme_bw()) {
  # Create visible binding for R CMD check.
  time <- residual <- NULL

  trans.string <- ifelse(unique(residuals$transform) == "identity", "t",
    paste0(unique(residuals$transform), "(t)")
  )

  gg.zph <- ggplot2::ggplot(residuals, ggplot2::aes(x = time, y = residual)) +
    ggplot2::geom_point() +
    ggplot2::facet_wrap(~variable, nrow = 2, scales = "free_y") +
    ggplot2::xlab(trans.string) +
    ggplot2::ylab(expression(beta(t)))

  if (hline) {
    gg.zph <- gg.zph + ggplot2::geom_hline(
      yintercept = hline_yintercept, col = hline_col,
      linewidth = hline_size, lty = hline_lty, alpha = hline_alpha
    )
  }

  if (sline) {
    gg.zph <- gg.zph + ggplot2::geom_smooth(
      col = sline_col, se = sline_se, method = "loess",
      linewidth = sline_size, lty = sline_lty, alpha = sline_alpha,
      formula = y ~ x
    )
  }

  gg.zph <- gg.zph + plot_theme

  gg.zph
}

#' Plot smoothed hazards of survival data
#'
#' This function generates a plot showing the hazards of the underlying
#' survival data, along with the hazards
#' predicted by different models from a \code{\link[survHE]{fit.models}} object.
#' It provides a visual comparison between observed hazards
#' and the hazards predicted by different models.
#'
#' @param data The survival data as a data frame with columns
#'   \code{time} and \code{event}.
#' @param time The name of the time variable in data.
#' @param event The name of the event variable in data.
#' @param fits The \code{\link[survHE]{fit.models}} object containing
#'   survival models
#' @param t A vector of time points at which to calculate the hazards.
#' @param group The group number of the strata
#' @param title The title of the plot.
#' @param subtitle The subtitle of the plot.
#' @param ylab The label for the y-axis.
#' @param xlab The label for the x-axis.
#' @param ylimit The upper limit of the y-axis to adjust the scale of the plot.
#'
#' @param font.family The name of the font for the plot. Default is
#' "Roboto Condensed".
#' @param plot.theme ggplot2 theme for the plot. Default is
#' \code{\link{theme_bw}()}.
#' @param use_plotly Optional. Whether to return a `plotly` output
#' for the plots. Default is FALSE.
#'
#' @importFrom rlang .data
#' @importFrom bshazard bshazard
#' @importFrom dplyr bind_rows
#' @importFrom ggplot2 ggplot
#' @importFrom ggplot2 geom_line
#' @importFrom ggplot2 geom_ribbon
#' @importFrom ggplot2 guides
#' @importFrom ggplot2 guide_legend
#' @importFrom ggplot2 ylim
#' @importFrom plotly ggplotly
#' @importFrom plotly config
#' @importFrom plotly layout
#' @importFrom survival Surv
#' @importFrom stats as.formula
#'
#' @export
#'
#' @return A ggplot object representing the plot of hazards.
#'
#' @examples
#' \dontrun{
#' library(survival)
#'
#' example <- lung |>
#'   mutate(event = status) |>
#'   select(time, event, sex)
#'
#' models <- survHE::fit.models(
#'   formula = Surv(time, event) ~ as.factor(sex),
#'   data = example,
#'   distr = c("exp", "weibull"),
#'   method = "mle"
#' )
#'
#' plot_smoothed_hazards(
#'   data = example,
#'   time = "time",
#'   event = "event",
#'   fits = models,
#'   t = 0:2000,
#'   title = "Smoothed hazards"
#' )
#' }
#'
plot_smoothed_hazards <- function(data,
                                  time,
                                  event,
                                  fits,
                                  t,
                                  # Optional arguments below
                                  group = 1,
                                  title = "",
                                  subtitle = "",
                                  ylab = "Hazard",
                                  xlab = "Time",
                                  ylimit = NULL,
                                  font.family = "Roboto Condensed",
                                  plot.theme = theme_bw(),
                                  use_plotly = FALSE) {
  # Appeasing R CMD check
  dist <- est <- lcl <- ucl <- NULL

  # Define the survival formula for bshazard
  my_formula <- stats::as.formula(
    paste0("survival::Surv(time = ", time, ", event = ", event, ") ~ 1")
  )

  # Calculate smoothed estimate of hazards based on B-splines (bshazard)
  observed_hazards <- with(
    bshazard::bshazard(my_formula,
      data = data,
      verbose = FALSE
    ),
    data.frame(time, hazard, lower.ci, upper.ci)
  ) |>
    dplyr::rename(
      est = .data$hazard,
      lcl = .data$lower.ci,
      ucl = .data$upper.ci
    )

  # Label the observed hazards and assign a thicker line width for the plot
  observed_hazards$dist <- "Observed"
  observed_hazards$linewidth <- 2.5

  # Obtain the predicted hazards from the fits
  predicted_hazards <- lapply(fits$models, function(dist) {
    summary_hazards <- as.data.frame(
      summary(dist, type = "hazard", t = t, ci = FALSE)[[group]]
    )

    # Thinner linewidth for non-observed hazards
    summary_hazards$linewidth <- 1

    return(summary_hazards)
  })

  # Combine predicted hazards into manageable object
  predicted_hazards <- Map(cbind,
    predicted_hazards,
    dist = names(predicted_hazards)
  )

  # Combine observed and predicted hazards into one object
  all_hazards <- do.call(
    dplyr::bind_rows,
    c(list(observed_hazards), predicted_hazards)
  )

  # Put the "Observed" line at the top of the plot legend.
  all_hazards$dist <- factor(all_hazards$dist,
    levels = unique(all_hazards$dist)
  )

  # Sometimes the estimated hazard is relatively much larger for a distribution
  # that it extends the y-axis significantly and makes it difficult to interpret
  # the plot.
  # The below logic attempts to define a reasonable upper limit for the y-axis.
  if (is.null(ylimit)) {
    # Obtain maximum estimated hazard
    max_est_hazard <- max(all_hazards$est, na.rm = TRUE)

    # Obtain upper confidence interval of observed hazard
    max_observed_u <- max(observed_hazards$ucl, na.rm = TRUE)

    # If estimated hazards don't go beyond the upper confidence limit of the
    # observed hazards, that's fine. Otherwise, extend the plot arbitrarily.
    if (max_observed_u > max_est_hazard) {
      max_hazard <- max_observed_u
    } else {
      max_hazard <- max_observed_u * 4
    }

    # Don't need to show hazards that would go beyond 1.
    ylimit <- min(1, max_hazard)
  }

  # Create the plot window
  out <- ggplot2::ggplot(all_hazards, aes(
    x = .data$time,
    y = .data$est,
    group = .data$dist
  )) +
    # Add the lines
    ggplot2::geom_line(aes(col = .data$dist, linewidth = I(.data$linewidth)),
      na.rm = TRUE
    ) +
    # Add labels
    labs(
      col = "Models",
      y = ylab,
      x = xlab,
      title = title,
      subtitle = subtitle
    ) +
    # Legend line width matching that in plot
    ggplot2::guides(
      colour = ggplot2::guide_legend(override.aes = list(linewidth = 1))
    ) +
    # Assign y limit.
    ggplot2::ylim(NA, ylimit)

  if (!use_plotly) {
    # Add the ribbon for the confidence interval
    out <- out +
      ggplot2::geom_ribbon(
        data = observed_hazards,
        aes(
          ymin = .data$lcl,
          ymax = .data$ucl,
          fill = .data$dist
        ),
        alpha = 0.3, # transparency
        show.legend = FALSE
      )
  }

  out <- out + plot.theme +
    theme(
      text = element_text(family = font.family),
      plot.title = element_text(family = font.family),
      plot.subtitle = element_text(family = font.family),
      axis.title.x = element_text(family = font.family),
      axis.title.y = element_text(family = font.family),
      axis.text.x = element_text(family = font.family),
      axis.text.y = element_text(family = font.family)
    )

  # Conditionally convert to a plotly object
  if (use_plotly) {
    # Define the 'text' aesthetic used for hover tooltips
    out_plotly <- out + aes(text = paste0(
      "<b>",
      dist,
      "</b>",
      " Time: ",
      format(time, big.mark = ",", digits = 2, nsmall = 2, trim = TRUE),
      ", Hazard: ",
      sprintf(est, fmt = "%.3f"),
      ifelse(dist == "Observed",
        paste0(
          " (",
          sprintf(lcl, fmt = "%.3f"),
          ", ",
          sprintf(ucl, fmt = "%.3f"),
          ")"
        ),
        ""
      )
    ))

    # Convert ggplot to plotly via ggplotly
    # Disable some options, otherwise overwhelming.
    out_plotly <- plotly::ggplotly(out_plotly, tooltip = "text") |>
      plotly::config(
        modeBarButtonsToRemove = c(
          "zoom",
          "pan2d",
          "zoomIn",
          "zoomOut",
          "autoScale",
          "select2d",
          "lasso2d"
        ),
        displaylogo = FALSE
      ) |>
      plotly::layout(hovermode = "x unified")

    # ggplotly seems to convert the distributions in the legend to:
    # "(Exponential,1)"
    # so here the code removes the "(,1)" wrapping.
    for (i in seq_along(out_plotly[["x"]][["data"]])) {
      temp_name <- out_plotly[["x"]][["data"]][[i]][["name"]]
      if (startsWith(temp_name, "(") && endsWith(temp_name, ",1)")) {
        out_plotly[["x"]][["data"]][[i]][["name"]] <-
          substring(
            temp_name,
            2,
            nchar(temp_name) - 3
          )
      }
    }

    return(out_plotly)
  }

  out
}
